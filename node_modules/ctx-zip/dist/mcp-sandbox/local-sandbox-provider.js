import { execFile, spawn } from "child_process";
import * as fs from "fs";
import * as path from "path";
import { promisify } from "util";
const execFileAsync = promisify(execFile);
/**
 * Command result implementation for local execution
 */
class LocalCommandResult {
    exitCode;
    stdoutData;
    stderrData;
    constructor(exitCode, stdoutData, stderrData) {
        this.exitCode = exitCode;
        this.stdoutData = stdoutData;
        this.stderrData = stderrData;
    }
    async stdout() {
        return this.stdoutData;
    }
    async stderr() {
        return this.stderrData;
    }
}
/**
 * Local filesystem sandbox provider for development and debugging
 *
 * This provider writes files to a local directory and executes commands
 * using Node.js child_process. Useful for:
 * - Debugging MCP client code without E2B
 * - Local development and testing
 * - Inspecting generated files directly
 */
export class LocalSandboxProvider {
    workspacePath;
    cwd;
    sandboxId;
    constructor(workspacePath) {
        this.workspacePath = workspacePath;
        this.cwd = workspacePath;
        this.sandboxId = `local-${Date.now()}`;
    }
    /**
     * Create a new local sandbox
     */
    static async create(options = {}) {
        const sandboxDir = options.sandboxDir || "./.sandbox";
        const cleanOnCreate = options.cleanOnCreate ?? true;
        // Resolve to absolute path
        const workspacePath = path.resolve(sandboxDir);
        console.log(`✓ Creating local sandbox at: ${workspacePath}`);
        // Clean if requested
        if (cleanOnCreate && fs.existsSync(workspacePath)) {
            console.log(`  Cleaning existing sandbox directory...`);
            fs.rmSync(workspacePath, { recursive: true, force: true });
        }
        // Create directory
        if (!fs.existsSync(workspacePath)) {
            fs.mkdirSync(workspacePath, { recursive: true });
            console.log(`  Created directory: ${workspacePath}`);
        }
        console.log(`✓ Local sandbox ready`);
        return new LocalSandboxProvider(workspacePath);
    }
    /**
     * Write multiple files to the local filesystem
     */
    async writeFiles(files) {
        console.log(`✓ Writing ${files.length} file(s) to local filesystem...`);
        for (const file of files) {
            const content = file.content.toString("utf-8");
            // Handle paths that are already absolute and within workspace
            let fullPath;
            if (path.isAbsolute(file.path)) {
                // If the path is already absolute and starts with workspace path, use it directly
                if (file.path.startsWith(this.workspacePath)) {
                    fullPath = file.path;
                }
                else {
                    // If absolute but not in workspace, make it relative and join
                    fullPath = path.join(this.workspacePath, file.path.substring(1));
                }
            }
            else {
                // Relative path - join with workspace
                fullPath = path.join(this.workspacePath, file.path);
            }
            console.log(`  Writing: ${fullPath} (${content.length} bytes)`);
            // Ensure directory exists
            const dirPath = path.dirname(fullPath);
            if (!fs.existsSync(dirPath)) {
                console.log(`  Creating directory: ${dirPath}`);
                fs.mkdirSync(dirPath, { recursive: true });
            }
            // Write the file
            fs.writeFileSync(fullPath, content, "utf-8");
            console.log(`  ✓ Written: ${fullPath}`);
        }
        console.log(`✓ Files written successfully`);
    }
    /**
     * Execute a command locally using Node.js child_process
     */
    async runCommand(command) {
        const fullCommand = [command.cmd, ...command.args].join(" ");
        console.log(`✓ Executing local command: ${fullCommand}`);
        console.log(`  Working directory: ${this.cwd}`);
        try {
            // Use spawn for better output handling and long-running commands
            const result = await new Promise((resolve, reject) => {
                const proc = spawn(command.cmd, command.args, {
                    cwd: this.cwd,
                    shell: true,
                    env: { ...process.env },
                });
                let stdout = "";
                let stderr = "";
                proc.stdout?.on("data", (data) => {
                    const chunk = data.toString();
                    stdout += chunk;
                    // Real-time output for debugging
                    process.stdout.write(chunk);
                });
                proc.stderr?.on("data", (data) => {
                    const chunk = data.toString();
                    stderr += chunk;
                    // Real-time error output
                    process.stderr.write(chunk);
                });
                proc.on("close", (code) => {
                    resolve({
                        exitCode: code || 0,
                        stdout,
                        stderr,
                    });
                });
                proc.on("error", (error) => {
                    reject(error);
                });
            });
            console.log(`  Exit code: ${result.exitCode}`);
            console.log(`  Stdout length: ${result.stdout.length} chars`);
            console.log(`  Stderr length: ${result.stderr.length} chars`);
            return new LocalCommandResult(result.exitCode, result.stdout, result.stderr);
        }
        catch (error) {
            console.error(`  Error executing command: ${error}`);
            throw error;
        }
    }
    /**
     * Cleanup the sandbox (no-op for local, files remain for inspection)
     */
    async stop() {
        console.log(`✓ Local sandbox stopped (files preserved at: ${this.workspacePath})`);
    }
    /**
     * Get the unique sandbox identifier
     */
    getId() {
        return this.sandboxId;
    }
    /**
     * Get the workspace directory path
     */
    getWorkspacePath() {
        return this.workspacePath;
    }
    /**
     * Set the working directory for subsequent commands
     */
    setWorkingDirectory(path) {
        this.cwd = path;
    }
    /**
     * Get the absolute path for inspection
     */
    getAbsolutePath(relativePath) {
        if (relativePath) {
            return path.join(this.workspacePath, relativePath);
        }
        return this.workspacePath;
    }
}
