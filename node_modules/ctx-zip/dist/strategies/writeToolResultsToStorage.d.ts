import type { ModelMessage } from "ai";
import type { StorageAdapter } from "../storage/types";
/**
 * Determine whether a message has textual content (string or text parts).
 * Used to detect conversational boundaries for compaction.
 */
export declare function messageHasTextContent(message: ModelMessage | any): boolean;
/**
 * Controls where the compaction window starts.
 *
 * - "since-last-assistant-or-user-text": Start after the most recent assistant/user text message.
 *   Use this to compact only the latest turn and keep recent context intact. (Recommended default)
 * - "entire-conversation": Start at the beginning. Use this to re-compact the full history
 *   or when earlier tool outputs also need persisting.
 */
/**
 * Controls where the compaction window starts.
 *
 * - "since-last-assistant-or-user-text": Start after the most recent assistant/user text message.
 *   Use this to compact only the latest turn and keep recent context intact. (Recommended default)
 * - "entire-conversation": Start at the beginning. Use this to re-compact the full history
 *   or when earlier tool outputs also need persisting.
 * - { type: "first-n-messages", count: number }: Keep the first N messages intact and start
 *   compaction afterwards. Useful to preserve initial system/instructions or early context.
 */
export type Boundary = "since-last-assistant-or-user-text" | "entire-conversation" | {
    type: "first-n-messages";
    count: number;
};
/**
 * Determine the starting index of the compaction window based on the chosen boundary.
 */
/**
 * Determine the starting index of the compaction window based on the chosen boundary.
 */
export declare function detectWindowStart(messages: ModelMessage[] | any[], boundary: Boundary): number;
/**
 * Determine the [start, end) window for compaction based on the chosen boundary.
 * The end index is exclusive. The final assistant message (last item) is never compacted.
 */
export declare function detectWindowRange(messages: ModelMessage[] | any[], boundary: Boundary): {
    start: number;
    endExclusive: number;
};
/**
 * Options for the write-tool-results-to-storage compaction strategy.
 */
export interface WriteToolResultsToStorageOptions {
    /** Where to start compacting from in the message list. */
    boundary: Boundary;
    /** Storage adapter used to resolve keys and write content. */
    adapter: StorageAdapter;
    /** Converts tool outputs into strings before writing. Defaults to JSON.stringify. */
    serializeResult: (value: unknown) => string;
    /**
     * Names of tools that READ from previously written storage (e.g., read/search tools).
     * Their results will NOT be re-written; instead a friendly reference to the source is shown.
     * Provide custom names for your own reader/search tools.
     */
    storageReaderToolNames?: string[];
}
/**
 * Compaction strategy that writes tool-result payloads to storage and replaces their in-line
 * content with a concise reference to the persisted location.
 */
export declare function writeToolResultsToStorageStrategy(messages: ModelMessage[], options: WriteToolResultsToStorageOptions): Promise<ModelMessage[]>;
