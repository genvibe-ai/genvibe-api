import { randomUUID } from "node:crypto";
import { registerKnownKey } from "../storage/knownKeys";
function formatStoragePathForDisplay(storageUri, key) {
    if (!storageUri)
        return key;
    if (storageUri.startsWith("blob:")) {
        // blob root => blob:///<key>
        if (storageUri === "blob:" || storageUri === "blob:/") {
            return `blob:///${key}`;
        }
        // blob with prefix => blob://prefix/<key>
        if (storageUri.startsWith("blob://")) {
            const base = storageUri.replace(/\/$/, "");
            return `${base}/${key}`;
        }
        // Fallback
        return `${storageUri}:${key}`;
    }
    // Default formatting uses colon separation
    return `${storageUri}:${key}`;
}
/**
 * Determine whether a message has textual content (string or text parts).
 * Used to detect conversational boundaries for compaction.
 */
export function messageHasTextContent(message) {
    if (!message)
        return false;
    const content = message.content;
    if (typeof content === "string")
        return true;
    if (Array.isArray(content)) {
        return content.some((part) => part && part.type === "text" && typeof part.text === "string");
    }
    return false;
}
/**
 * Determine the starting index of the compaction window based on the chosen boundary.
 */
/**
 * Determine the starting index of the compaction window based on the chosen boundary.
 */
export function detectWindowStart(messages, boundary) {
    // Start compaction after the first N messages (keep the first N intact)
    if (typeof boundary === "object" &&
        boundary !== null &&
        boundary.type === "first-n-messages") {
        const countRaw = boundary.count;
        const n = Number.isFinite(countRaw)
            ? Math.max(0, Math.floor(countRaw))
            : 0;
        const len = Array.isArray(messages) ? messages.length : 0;
        // We never compact the final assistant message (loop iterates to length - 1),
        // so clamp the start within [0, len - 1]
        const upperBound = Math.max(0, len - 1);
        return Math.min(n, upperBound);
    }
    if (boundary === "entire-conversation")
        return 0;
    const msgs = Array.isArray(messages) ? messages : [];
    let windowStart = 0;
    for (let i = msgs.length - 2; i >= 0; i--) {
        const m = msgs[i];
        const isBoundary = m &&
            (m.role === "assistant" || m.role === "user") &&
            messageHasTextContent(m);
        if (isBoundary) {
            windowStart = i + 1;
            break;
        }
    }
    return windowStart;
}
/**
 * Determine the [start, end) window for compaction based on the chosen boundary.
 * The end index is exclusive. The final assistant message (last item) is never compacted.
 */
export function detectWindowRange(messages, boundary) {
    const len = Array.isArray(messages) ? messages.length : 0;
    const lastIndex = Math.max(0, len - 1);
    if (len <= 1)
        return { start: 0, endExclusive: 0 };
    // Preserve the latest N messages; compact the older ones.
    if (typeof boundary === "object" &&
        boundary !== null &&
        boundary.type === "first-n-messages") {
        const countRaw = boundary.count;
        const n = Number.isFinite(countRaw)
            ? Math.max(0, Math.floor(countRaw))
            : 0;
        // End exclusive should stop before the latest N messages (and before the final assistant message)
        const endExclusive = Math.max(0, Math.min(len - 1, len - n - 1));
        return { start: 0, endExclusive };
    }
    if (boundary === "entire-conversation") {
        return { start: 0, endExclusive: Math.max(0, len - 1) };
    }
    const start = detectWindowStart(messages, boundary);
    return { start, endExclusive: Math.max(0, len - 1) };
}
function isToolMessage(msg) {
    return msg && msg.role === "tool" && Array.isArray(msg.content);
}
/**
 * Compaction strategy that writes tool-result payloads to storage and replaces their in-line
 * content with a concise reference to the persisted location.
 */
export async function writeToolResultsToStorageStrategy(messages, options) {
    const msgs = Array.isArray(messages) ? [...messages] : [];
    const lastMessage = msgs[msgs.length - 1];
    const endsWithAssistantText = lastMessage &&
        lastMessage.role === "assistant" &&
        messageHasTextContent(lastMessage);
    if (!endsWithAssistantText)
        return msgs;
    const { start: windowStart, endExclusive } = detectWindowRange(msgs, options.boundary);
    for (let i = windowStart; i < Math.min(endExclusive, msgs.length - 1); i++) {
        const msg = msgs[i];
        if (!isToolMessage(msg))
            continue;
        for (const part of msg.content) {
            if (!part || part.type !== "tool-result" || !part.output)
                continue;
            // Reference-only behavior for tools that read from storage
            const defaultStorageReaderNames = ["readFile", "grepAndSearchFile"];
            const configuredNames = options.storageReaderToolNames &&
                options.storageReaderToolNames.length > 0
                ? options.storageReaderToolNames
                : defaultStorageReaderNames;
            const storageReaderSet = new Set(configuredNames);
            if (part.toolName && storageReaderSet.has(part.toolName)) {
                const output = part.output;
                let fileName;
                let key;
                let storage;
                if (output && output.type === "json") {
                    if (output.value && typeof output.value.fileName === "string") {
                        fileName = output.value.fileName;
                    }
                    if (output.value && typeof output.value.key === "string") {
                        key = output.value.key;
                    }
                    if (output.value && typeof output.value.storage === "string") {
                        storage = output.value.storage;
                    }
                }
                else if (output && typeof output.fileName === "string") {
                    fileName = output.fileName;
                }
                else if (output) {
                    // Fallback: some runtimes may deliver plain objects instead of { type: 'json', value }
                    if (typeof output.key === "string") {
                        key = output.key;
                    }
                    if (typeof output.storage === "string") {
                        storage = output.storage;
                    }
                }
                const display = storage && key
                    ? `Read from storage: ${formatStoragePathForDisplay(storage, key)}. Key: ${key}`
                    : `Read from file: ${fileName ?? "<unknown>"}`;
                part.output = {
                    type: "text",
                    value: display,
                };
                if (storage && key) {
                    registerKnownKey(storage, key);
                }
                continue;
            }
            const output = part.output;
            let contentToPersist;
            if (output && output.type === "json" && output.value !== undefined) {
                contentToPersist =
                    typeof output.value === "string"
                        ? output.value
                        : options.serializeResult(output.value);
            }
            else if (output &&
                output.type === "text" &&
                typeof output.text === "string") {
                contentToPersist = output.text;
            }
            if (!contentToPersist)
                continue;
            const fileName = `${randomUUID()}.txt`;
            const key = options.adapter.resolveKey(fileName);
            await options.adapter.write({
                key,
                body: contentToPersist,
                contentType: "text/plain",
            });
            const adapterUri = options.adapter.toString();
            const isFile = adapterUri.startsWith("file:");
            const writtenPrefix = isFile ? "Written to file" : "Written to storage";
            part.output = {
                type: "text",
                value: `${writtenPrefix}: ${formatStoragePathForDisplay(adapterUri, key)}. Key: ${key}. Use the read/search tools to inspect its contents.`,
            };
            registerKnownKey(adapterUri, key);
        }
    }
    return msgs;
}
