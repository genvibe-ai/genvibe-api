import { BaseClient, type Parsed, type RequestParams } from "./base-client";
import { SandboxResponse, CommandResponse, CommandFinishedResponse, LogLine, ExtendTimeoutResponse } from "./validators";
import { FileWriter } from "./file-writer";
import { z } from "zod";
import { WithPrivate } from "../utils/types";
export declare class APIClient extends BaseClient {
    private teamId;
    private tokenExpiry;
    constructor(params: {
        baseUrl?: string;
        teamId: string;
        token: string;
    });
    private ensureValidToken;
    protected request(path: string, params?: RequestParams): Promise<Response>;
    getSandbox(params: {
        sandboxId: string;
        signal?: AbortSignal;
    }): Promise<Parsed<{
        sandbox: {
            region: string;
            status: "pending" | "running" | "stopping" | "stopped" | "failed";
            timeout: number;
            cwd: string;
            id: string;
            memory: number;
            vcpus: number;
            runtime: string;
            requestedAt: number;
            createdAt: number;
            updatedAt: number;
            duration?: number | undefined;
            startedAt?: number | undefined;
            requestedStopAt?: number | undefined;
            stoppedAt?: number | undefined;
        };
        routes: {
            url: string;
            port: number;
            subdomain: string;
        }[];
    }>>;
    createSandbox(params: WithPrivate<{
        ports?: number[];
        projectId: string;
        source?: {
            type: "git";
            url: string;
            depth?: number;
            revision?: string;
            username?: string;
            password?: string;
        } | {
            type: "tarball";
            url: string;
        };
        timeout?: number;
        resources?: {
            vcpus: number;
        };
        runtime?: "node22" | "python3.13" | (string & {});
        signal?: AbortSignal;
    }>): Promise<Parsed<{
        sandbox: {
            region: string;
            status: "pending" | "running" | "stopping" | "stopped" | "failed";
            timeout: number;
            cwd: string;
            id: string;
            memory: number;
            vcpus: number;
            runtime: string;
            requestedAt: number;
            createdAt: number;
            updatedAt: number;
            duration?: number | undefined;
            startedAt?: number | undefined;
            requestedStopAt?: number | undefined;
            stoppedAt?: number | undefined;
        };
        routes: {
            url: string;
            port: number;
            subdomain: string;
        }[];
    }>>;
    runCommand(params: {
        sandboxId: string;
        cwd?: string;
        command: string;
        args: string[];
        env: Record<string, string>;
        sudo: boolean;
        signal?: AbortSignal;
    }): Promise<Parsed<{
        command: {
            name: string;
            args: string[];
            cwd: string;
            id: string;
            startedAt: number;
            sandboxId: string;
            exitCode: number | null;
        };
    }>>;
    getCommand(params: {
        sandboxId: string;
        cmdId: string;
        wait: true;
        signal?: AbortSignal;
    }): Promise<Parsed<z.infer<typeof CommandFinishedResponse>>>;
    getCommand(params: {
        sandboxId: string;
        cmdId: string;
        wait?: boolean;
        signal?: AbortSignal;
    }): Promise<Parsed<z.infer<typeof CommandResponse>>>;
    mkDir(params: {
        sandboxId: string;
        path: string;
        cwd?: string;
        signal?: AbortSignal;
    }): Promise<Parsed<{}>>;
    getFileWriter(params: {
        sandboxId: string;
        extractDir: string;
        signal?: AbortSignal;
    }): {
        response: Promise<Response>;
        writer: FileWriter;
    };
    listSandboxes(params: {
        /**
         * The ID or name of the project to which the sandboxes belong.
         * @example "my-project"
         */
        projectId: string;
        /**
         * Maximum number of sandboxes to list from a request.
         * @example 10
         */
        limit?: number;
        /**
         * Get sandboxes created after this JavaScript timestamp.
         * @example 1540095775941
         */
        since?: number | Date;
        /**
         * Get sandboxes created before this JavaScript timestamp.
         * @example 1540095775951
         */
        until?: number | Date;
        signal?: AbortSignal;
    }): Promise<Parsed<{
        sandboxes: {
            region: string;
            status: "pending" | "running" | "stopping" | "stopped" | "failed";
            timeout: number;
            cwd: string;
            id: string;
            memory: number;
            vcpus: number;
            runtime: string;
            requestedAt: number;
            createdAt: number;
            updatedAt: number;
            duration?: number | undefined;
            startedAt?: number | undefined;
            requestedStopAt?: number | undefined;
            stoppedAt?: number | undefined;
        }[];
        pagination: {
            count: number;
            next: number | null;
            prev: number | null;
        };
    }>>;
    writeFiles(params: {
        sandboxId: string;
        cwd: string;
        files: {
            path: string;
            content: Buffer;
        }[];
        extractDir: string;
        signal?: AbortSignal;
    }): Promise<void>;
    readFile(params: {
        sandboxId: string;
        path: string;
        cwd?: string;
        signal?: AbortSignal;
    }): Promise<NodeJS.ReadableStream | null>;
    killCommand(params: {
        sandboxId: string;
        commandId: string;
        signal: number;
        abortSignal?: AbortSignal;
    }): Promise<Parsed<{
        command: {
            name: string;
            args: string[];
            cwd: string;
            id: string;
            startedAt: number;
            sandboxId: string;
            exitCode: number | null;
        };
    }>>;
    getLogs(params: {
        sandboxId: string;
        cmdId: string;
        signal?: AbortSignal;
    }): AsyncGenerator<z.infer<typeof LogLine>, void, void> & Disposable & {
        close(): void;
    };
    stopSandbox(params: {
        sandboxId: string;
        signal?: AbortSignal;
    }): Promise<Parsed<z.infer<typeof SandboxResponse>>>;
    extendTimeout(params: {
        sandboxId: string;
        duration: number;
        signal?: AbortSignal;
    }): Promise<Parsed<z.infer<typeof ExtendTimeoutResponse>>>;
}
